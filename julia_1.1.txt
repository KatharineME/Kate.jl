# ==============================================================================
https://docs.julialang.org/en/v1/
# ==============================================================================

# ==============================================================================
Overview
# ==============================================================================
Modern compiling techniques, like just-in-time (JIT) compilation implemented using LLVM, enable Julia

Julia is a dynamic language that nearly as fast as C

Dynamic languages aren't type-less

There are various types in Julia

Object typing is optional and can be inferred

Multiple dispatch matches the most specific method with a function call

Julia libraries are written in Julia itself

Static languages require typing, which is required for compiling and can't be manipulated at run time

Object oriented language functions are owned by the 1st argument, an Object

Non-vectorized code is often faster

Julia is designed for parallelism in mind

In read-eval-print-loop (REPL), Main, the last expression output is printed

include to evaluate content of a .jl file

Running .jl as a script introduces global constant variable PROGRAM_FILE which is the script name and ARGS which is the arguments

When expression is used instead of a script with -e, PROGRAM_FILE == ""

Julia can start in parallel mode with -p N_WORKER|auto or --machine-file FILE, where each line in FILE specifies a password-less SSH machine that has Julia installed at the same location

Julia runs ~/.julia/config/startup.jl at start up

unicodes can be used as a variables

?symbol prints the unicode for symbol

Julia errors when rebinding built-in constants or functions

1 and 1.0 are numeric literals of int and float respectively, and their binary-in-memory representations as objects are numerical primitives

Sys.WORD_SIZE indicates whether a system is 32 or 64 bit

Large integers are always Int64 regardless of the system types

Unsigned integers use 0x prefix and hexadecimal (base 16); the size of of the unsigned value is determined by the number of hex digit used

typemax(Int8) == 127

typemax(UInt8) == 255

lpad(String, Integer)

typemax(Int64) + 1 == typemin(Int64); or use BigInt

_ can be digit separator as in 1_000_000

0.0 == -0.0 but bitstring(0) != bitstring(-0)

Inf and NaN are float

0/0 == NaN

Inf - Inf == NaN

Inf / Inf == NaN

0 * Inf == NaN

typemin(Float32) == -Inf32

eps(x) outputs the next floating-point value larger than x

There are more floats near 0

Each consecutive float is adjacent in binary integer representation

Promotion makes working with number of multiple types possible

. operator (broadcast) performs operation element-wise in place

a .^ b == (^).(a, b), where a and b can be arrays and scalars, arrays of the same size, arrays of different shapes (combine row and column to produce matrix)

Nested broadcasting fuses each function into 1 call so the data is iterated once: f.(g.(A)) if [f(g(a)) for a in A]

Operators are parsed as function calls a + b + c is parsed as +(a, b, c) and x .+ 3 .* x.^2 becomes (+).(x, (*).(3, (^).(x, 2)))

Combining . with numerical literals isn't allowed because 1.*x is ambiguous

Int and -Inf are greater and less than everything except NaN

NaN comparison is always false, even NaN != NaN

[1 NaN] == [1 NaN] (false because NaN != NaN)

isequal(NaN, NaN) ==  true

isequal([1 NaN], [1 NaN]) == true

isequal(NaN, NaN32) == true

-0.0 == 0.0

isequl(-0.0, 0.0) == false

T(x) and convert(T, x) convert x to type T

1//0 and -3//0 are infinite rational numbers; there is no NaN rational number

ASCII defines 128 characters each assigned with an ID, leaving out many chars

UTF-8 is back compatible with ASCII

Unicode include non-ASCII chars too

When defining a function that expects a string, declare the type as AbstractString in order to accept any string types

Strings are immutable

Char(10) == '\n'

Char(120) == 'x'

Char(0x110000) == '\U110000'

Last index can be specified as [end] and the one before last by [end-1]

str[k] == '' != str[k:k] == ""

Indexing string copies the while SubString(string, a, b) creates a view

Non-ASCII characters can take up different bytes making indexing tricky

UTF-8 uses variable length encoding, so length(s) <= lastindex(s) because length(s) is the number of char in s and each char can be encoded with variable length

Be careful working with invalid UTF-8 strings

The triple quote dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening """ and lines containing only spaces or tabs (the line containing the closing """ is always included.

Use regex with occursin, match, and replace

nothing is a type and a thing; REPL won't print nothing and setting nothing as the last function definition is a convention for returning nothing

Function arguments are passed by sharing argument values

A function returns the last expression

When using control flows, explicit return may be necessary

Specify function return type by f(...)::Int8

Operators (non-short-circuiting ones) are functions with special infix syntax; 1 + 2 + 3 becomes +(1, 2, 3)

Infix possible functions can be reassigned to another variable but the new variable can't be infix

Anonymous function accepting multiple arguments is: (a, b, c) -> +(a, b, c)

f(a, b, c...) = (a, b, c) will always return something like (a, b, ()) because c... is expecting a collection of things

... in function definition collects and ... in function call splats (make sure splatting results in allowed number of things) varargs and kwargs

Optional arguments results in defining the function with different number of arguments

Optional arguments are just a convenient syntax for writing multiple method definitions with different numbers of arguments

Add keyword arguments after semicolon f(a, b=0; c=expression); expression is evaluated only when c is missing

Data(y, [m, d]) means that that m and d are optional arguments

f(x; y) requires keyword argument y

f(x; kwargs..., y=0); it's possible that y is already in kwargs; in whch case y overwrites kwargs['y']

Keyword arguments can't be duplicated as in f(x; y=0, y=1)

map([...]) do a, b
  do stuff with a, b
end

open("/path/to/blah", 'w') do io
  do stuff with io
end

do block like any other function can capture variables from its enclosing scope; can harm performance

f.(pi, A) is like f(pi, a) for a in A

f(v1, v2) returns a vector consisting of f(v1[i], v2[i]) but errors if length(v1) != length(v2)

Maximum efficiency occurs when the output array for vectorized output is preallocated so that repeated calls don't allocate new arrays each time

Achieve good efficiency by X .= Y .^ 2, which overwrites X element wise in place

Macro @. converts any function expression into . form: @. X = sin(cos(Y)) becomes X .= sin.(cos.(Y))

X .+= Y

begin-end block and ;-chain can be multiple expressions

if block, begin-end block, and ;-chain return the output of the last expression

z == c in the following 2 expressions

z = begin
  a
  b
  c
end

z  = (a; b; c)

Non-boolean like 0 and 1 can't be interpreted as bool

a ? a_true : a_false

Either the left or the right expression is evaluated as needed

break terminates any loop and continue skip a loop iteration

Simultaneously iterating through multiple ranges results in cartesian indexing, which is all or nothing looping

for i in 1:10, j in 1:10
  println(i, j)
end

When cartesian indexing, assigning an index to a value has no effect; can't alter cartesian indexing and break breaks the entire looping

throw Error("error message")

Error message should start with a lower case letter

try
  ...
catch e
  ...

Avoid try-catch because error handling is slower than condition checking and branching

finally block runs when an earlier piece of code successfully exits

A task (also known as coroutine, symmetric coroutine, lightweight thread, cooperative multitask, or one-shot continuation) is a run that can be interrupted and resumed later

When various pieces of required work aren't naturally related, each piece can be a task

Channel is a queue that multiple tasks can access

Channel method creates a channel bound task, by accepting a method that takes a single argument of type Channel

The task constructor excepts a 0-argument function; Task(() -> f(args...)) or @task f(args...)

There are 2 types of scope: global and local scopes

Julia uses lexical scoping, which means that a function's scope inherits from where it is defined

Each module is a global scope and a namespace

Global variables can only be changed within their global scope

Most blocks (except if and begin blocks) introduce a local scope, inheriting variables from the parent local scope for both reading and writing

A newly created variable in local scope can't be referenced by a parent scope

Inner local scope can update variables inherited from the parent local scope, but local keyword can ensure that a variable is local to the inner local scope; so nested functions can modify the parent scope's local variables

The 1st level local scope creates a closure

global variables are inherited for reading butn't writing, still within a local scope, a global variable can be modified using global keyword, which can be anywhere

Specify updating global variable and defining inner local variable

Inner scope can capture variables from the outer scope

A function can use parent scope variable that has yet to be defined

let creates a closure

let creates a new variable binding within its new local scope

Each loop freshly allocate a local scope, as if the loop body starts with let

Global constants can't be rebound to a different value

# ==============================================================================
Types
# ==============================================================================
Static language requires typing everything

Dynamic language infers type at run time by looking at the value, which may be of any type (polymorphism)

In Julia, every value is an object with type (always) and object of unspecified type belongs to Any type

Types can have parameter

Concrete type can't have subtype, but only abstract type can

:: is "is an instance of" and <: is "is subtype of" operators and can be applied to any object in place

When :: or <: is applied on a variable on an expression computing a value, the operators checks for the type

When :: or <: is applied on a variable on a left hand side of an assignment (only in a local scope), it declares the variable to always have the specified type

:: uses convert() to convert the left side variable to a desired type

In Julia's type hierarchy, Any is the root, abstract type is parent to concrete type, and Union is the nadir, which can't have value or subtype

abstract type <name> <: <supertype> end

Number ==> Real ==> AbstractFloat
                ==> Integer ==> Signed
                            ==> Unsigned

Julia dispatch chooses the method with the most specific typing

Writing a method with abstract types creates methods for concrete types inheriting from the abstract type

Smallest primitive type unit is 8 bits (1 byte)

Unlike most languages, Julia allows defining of primitive types, which is a concrete type whose data consists of plain old bits

primitive type <name> <: <supertype> <bits> end

Composite type is defined with struct and is a collection of names fields (in many languages, only compsite type can be defined by a user)

When a type is applied like a function, it is called constructor

fieldnames(Type) prints fields of a struct

Composite objects are immutable

Immutable means binding can't change but the already bound value can be mutable

Immutable composite object without a field is a singleton and there can be only 1 of such object (nothing is a singleton)

Mutable struct can create instances that are mutable

When considering making a struct mutable, ask whether two instances with the same field values would be considered identical or if they might need to change independently over time

Immutable objects and structs are defined by their bits, hence they are immutable once declared (memory allocated)

Concrete types have specific size thus storage layout

An immutable object can be copied freely because its copy and itself can't be distinguished

Mutable composite types can be defined with mutable struct and are heap-allocated and passed as pointers

Every Julia object except functions have types

Abstract, primitive, and composite types are all DataType and are explicitly declared, have names, have explicitly declared subtypes, and have parameters; a primitive type is a DataType of non-0 size without fields but with name; a composite type is a DataType of that has field name or 0 size

Union type includes as objects all instances of any of its argument type

Type declarations introduces a family of types one for each possible combination of parameter values

Parametric type introduce a whole family of new types, one for each possible combination of parameter values

Julia compiler generates a specialized code for each combination of types (on multiple branches)

Type parameters are written within a curly bracket after the name

struct Point{T}
  x::T
  y::T
end

Point{T} introduces unlimited number of types, each a usable concrete type

(Point{Float64} <: Point{Real}) == false even though (Float64 <: Real) == true

(Point{Float64} <: Point{<:Real}) == true

Array{Float64} holds a contiguous memory block of 64-bit floating point values where as Array{Real} needs a contiguous Real objects which may be larger than 64 bits

f(p::Point{Real}) can't accept Point{Float64} but f(p::Point{<:Real}) can

Point{T<:Real} is equivalent at Point{T} where T<:Real

In the absence of any special constructor declaration, there are 2 ways of creating a new composite objects: 1) explicitly declare type parameter; 2) use argument of exact type, which is inferred as the type parameter

Parametric abstract types create a common interface shared by all subtypes

Tuple types are generated on demand

Tuple{Any} is considered an abstract type

The last parameter of a tuple type can be the special type Vararg

Vararg{T, N} corresponds to exactly N elements of type T; omitting N corresponds to any number of elements

Type(T) is the singleton type whose only instance if the object T

isa(A,Type{B}) is true if and only if A and B are the same object and that object is a type

Type is simply an abstract type which has all type objects as its instances, including, of course, singleton types

Singleton allows one to specialize function behavior on specific type values; useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments

Primitive types can also have parameters

primitive type Ptr{T} 64 end

Ptr and other parametric type like Array are UnionAll type, which is iterated union of types of all values of some parameter

UnionAll is written using the keyword where: Ptr is Ptr{T} where T, meaning all values whose type is Ptr{T} for some T (T is type variable)

where {T} can be where T if there is only 1 type

where T<:A where N (where can be chained)

Each where introduces a type variable: Array{T, N} where T  where N

A{B, C} requires A to be a UnionAll type, equivalent to A{B}{C} where A{B} is another UnionAll type (nesting explains why Array can be partially instantiated as Array{Float64} but not yet Array{Float64, 1})

Array{Int<:T<:Number} is a shorthand for Array{T} where Int<:T<:Number

where nesting can refer to outer type variable: Tuple(T, Array(S)) where S<:AbstractArray{T} where T<:Real which can be written as Tuple(T<:Real, Array(S<:AbstractArray{T}))

Array{Array{T, 1} where T, 1} defines a 1-dimensional array of 1-dimensional arrays, where each of the inner arrays consists of the same type but this type may vary from one inner array to the next (this is a concrete type)

Array{Array{T, 1}, 1} where T defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type (this is an abstract type)

Abstract type can't be constructed like AbstractType()

Vector{T} = Array{T, 1}

Only declared types have unambiguous super type and thus works with supertype

Julia dispatches on parametric type; Julia also allows plain bits to be parameters (in Array{T, N}, N is just an Int)

New method won't be available immediately

World age counter keeps track of the set of method definitions visible to a given runtime environment

Base.invokelatestt(f) makes f visible

# ==============================================================================
Methods
# ==============================================================================
Function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned

A function should be defined a method at a time, each working with a set of argument types (each method can be implemented freely to make the outward behavior of the function seamless and consistent)

Julia multiple dispatch looks at all arguments to calls the most specific (and appropriate) method when a function is called

The first method creates the function object and subsequent methods join the function object

Julia doesn't perform automatic casting; types must be explicitly specified

methods(f)

Catch-all method can be defined by defining a function without specifying all argument types (so they are all Any)

Function itself can have parameters (UnionAll)

myappend(v::Vector{T}, x::T) where {T}

For each type, T, the singleton type Type{T} is an abstract type whose only instance is the object T

Singleton type are useful because it allows one to specialize function behavior on specific type values. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.

In iterated dispatch, dispatch tries to match method layer at a time

In trait-based dispatch, conversion rules (as long as they are pure) from to common type (like promote_type) and a table of preferred pair-wise promotion rules reduce the problem of implementing every function for every pair of possible type arguments

This trait-based approach is also present in promote and promote_type

Output type computation can be forsee by: 1) define op that express the set of operations performed by the kernel of the algorithm; 2) compute the element type R of the result as promote_op(op, argument_types...) where argument_types is computed from eltype applied to each input; and 3) build the output structure

Isolate the logic for converting to the desired type and the computation to better compile

Varargs can be parametrically constrained: function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}

f(x::Vararg{Int}) can be written as f(::Int...)

Optional arguments are syntax for multiple method definitions: f(a=1,b=2) = ... translates into: f(a,b) = ...; f(a) = f(a,2); and f() = f(1,2)

Keyword arguments don't participate in method dispatch (they are processed after the matching method is defined)

Functors are non-functions with methods; they are specified by type instead of by name

Orthogonize function designs for better styling and less ambiguity

# ==============================================================================
Constructor
# ==============================================================================
Constructor creates an instance of composite type

Type object can be constructor

Constructor is function that constructs object, and can have multiple methods for different combination of input types

Constructor can call other constructor

Constructor defined within a constructor is inner constructor, which uses new, a function available only within a constructor

Inner constructor can enforce some logic

Outer constructor is equivalent to writing inner constructor that takes all of the objects fields as parameters and pass them to new

new can be called without all fields, resulting in constructing object with uninitialized reference (accessing uninitialized reference is an immediate error)

Instance of parametric composite type can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments to the constructor

Point(1, 2) == Point{Int64}(1, 2)

Point(1.0, 2.0) == Point{Float64}(1, 2)

Point{T} is a distinct constructor function for each type T

Without explicitly providing inner constructor, declaring Point{T<:Real} automatically provides an inner constructor, Point{T}, for each possible type T<:Real

promote converts all its arguments to a common type

# ==============================================================================
Conversion and Promotion
# ==============================================================================
Built in numerical types are automatically promoted to a common type to produce expected results

Compiler or interpreter must perform conversion before operation since different types have different bits

Julia relies on automatic dispatch for conversion and promotion

Use parse instead of convert to convert string into numbers

convert is called when assigning to a reference of declared type

Constructor and convert are similar but different

Singleton doesn't have to have a reference, as in Nothing or ::Type(MyType)

Promotion refers to converting values of mixed type to a single common type, which is not the same as the common parent type

Promotion can be used to define catch-all function

Set promotion rule by promote_rule(::Type{Float64}, ::Type{Float32}) = Float64 (symmetry is implied)

promote_type(varargs{::Type}...) to get the promoted type

# ==============================================================================
Interfaces
# ==============================================================================
Extend few specific methods to work for a custom type to create common interfaces to work with the custom type

Defining a subtype of AbstractArray inherits a rich set of behaviors

Defining AbstractArray subtype requires IndexStyle (linear or cartesian indexing)

Converting between linear indexing and cartesian indexing is expensive so defining indexing style (Base.IndexStyle) allows traits-based mechanism to enable efficient genetic code for all array types

Defining Base.size, Base.IndexStyle, and Base.getindex (tailored for Base.IndexStyle) are all it takes to define an AbstractArray subtype

StridedArray is subtype of AbstractArray and has interfaces

Any object that has axes and supports indexing can participate in broadcasting

# ==============================================================================
Running External Programs
# ==============================================================================
`echo hello` is a Cmd object

run(Cmd) runs Cmd, with Cmd output going to stdout, so run returns nothing

read(Cmd) returns stdout

Write to Cmd by
open(`less`, "w", stdout) do io
  for i in 1:3
    println(io, i)
  end
end

collect(`echo "hello world"`) run Cmd and returns an Array of stdout elements, ["echo", "hello world"]

$x interpolates x; treating x an 1 Cmd element (if x is a String, any space within x is escaped, in which case single quotes (') is inserted in a Cmd when displaying it)

Interpolating AbstractArray makes each array element into Cmd element as if interpolating each array element in order

When creating Cmd, cut-and-paste shell command into Cmd and, as necessary, interpolate Cmd element

Shell metacharacters such as |, &, and > should be quoted or escaped

Pipe by run(pipeline(`echo hello`, `cat`))

Run multiple commands in parallel by run(`echo hello` & `echo world`) (order is not fixed)

Piping is flexible run(pipeline(`echo hello` & `echo world`, `sort`))

Direct IO by pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")

# ==============================================================================
Performance tips
# ==============================================================================
Global variables can change so it's difficult for compiler to optimize code; so variables should be local or passed as argument

Performance critical code should be within a functions

Declare global variables as constants (if they don't change, which is often the case)

::Type specify non-constant global variable at when using it

Variables defined in REPL are global even if they don't have global prefix

Use @time to time

5 memory allocations happen when @time in global scopes



# ==============================================================================
Style guide
# ==============================================================================
Write independent functions as soon as possible

Code inside function runs faster than top level code

complex(float(x)) is superior than Complex{Float64}(x)

Julia doesn't penalize functions with general types because Julia automatically compiles a specialized version of the function

Handle excess argument diversity in the caller by specifying argument types

Function that modifies an argument should end with !

Avoid mixing various types

Use camel case for module and type names

Use lowercase for function and variable names

Don't use unnecessary static parameters

Use functions instead of macros because macros work only at the Main level

Avoid overloading

Overwriting an element definition updates it everywhere, so avoid collision by using different function name or use different type

Use isa or <: instead of == for testing types

Avoid using floats for numerical literals in generic code because floats are more dominant numerical values

# ==============================================================================
FAQ
# ==============================================================================
To free a memory, assign the variable to nothing and gc()

Main module types can't be redefined but can be re-included

abspath(PROGRAM_FILE) == @__FILE__ checks if a .jl is run as a script

atexist() runs a function when a script exists, even if exit by CTRL-C

Argument values aren't copied when passed into a function, but re-bound within the function to a local variable

import or include isn't allowed within a function

... collects multiple arguments into one in function definition

... splits one argument into many different in functions calls

Type stable function outputs specified type, helping Julia to prepare a fast code

Julia uses machine integer arithmetic, which has problem of overflowing, to maintain type stability

Not-Main module variables aren't serialized by value to the remote server

Function or struct declarations aren't serialized by value either, even if they are declared in Main

@everywhere can declare variable on all nodes

using is better than import because everything in Module is imported with import

using Module; Module.f(

import Module; f(

An object can't be null by default

Use Union{T, nothing} when type nothing is a possibility

Missing data in math sense should use missing object

An empty tuple is similar to nothing

x = 8; x += 1 (which becomes x = x + 1) doesn't modify the x because a number is immutable, but rather binds x with a new value of 9

@sync, @async, ReentrantLock

Zero-dimensional arrays are arrays of the form Array{T, 0} with size () and length 1 (prod(()) = 1) and accessed by A[] (A[], A[i], A[i, j] to access 0, 1, and 2 dimensional arrays respectively)

Scalars are iterable and has length and index, butn't 0-dimensional arrays

# ==============================================================================
Noteworthy differences from other languages
# ==============================================================================
A = B; modify B; A is modified

f(A); f modifies A; A is modified

Arrays aren't resized automatically; push! and append! resize an array

Literal numbers without decimal point create integers instead of floats, but may be promoted to BigInt for big numbers

[a b c] = hcat

[a; b; c] = vcat

[a b; c d] = hvcat

AbstractRange can act like a vector

Reductions such as sum, prod, and max (if specified without axis) are performed over every element

A == B doesn't result in a array; instead use A .== B

Structs don't support adding fields at runtime; use Dict to do so

Use filter for logical indexing

Logical indexing requires the index to be the same shape as the object being indexed

End a block with end

-> creates an anonymous function

Check for nothing by === nothing

There isn't pass

Iterables are 1-indexed and slicing includes the last element

Indentation doesn't matter

There isn't a line continuation syntax

Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered)

Julia is column ordered so looping in reverse can lead to faster performance

Updating operators rebind the variable being updated to a new data because A += B becomes A = A + B, so use broadcasting (or .) for updating in place

Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined

"$(expression)" evaluates expression and stringfies its output

// indicates a Rational number

#= =# indicates multiline comment

Result of expressions are automatically printed (suppressed by ;) only in interactive prompt

^ is exponential operator

Macros can be like functions @macro(arg1, arg2) and @macro arg1 arg2 are the same

Macro can start a block

# ==============================================================================
I/O and Network
# ==============================================================================
open(filename::AbstractString; keyword...) -> IOStream

Use keyword::Bool: read, write, create, truncate, append (default is only read=ture)

open(f:Function, args...; kwargs...) apply function to IOStream and close
